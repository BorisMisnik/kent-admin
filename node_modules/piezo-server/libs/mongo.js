/*!
 * Module: Module
 *
 * @author Andjey Guzhovskiy, <me.the.ascii@gmail.com>
 * @copyright (c) 2013 Andjey Guzhovskiy
 * @licence CLOSED
 * @version 0.0.1
 */

// libs
var util = require( 'util' ),
    emitter = require( 'events').EventEmitter,
    async = require( 'async' ),
    // database
    mongo = require( 'mongodb' ),
    ObjectID = require( '../utils/objectid' ),
    dot = require( '../utils/dot' );

var errors = {
    collection_name: 'Error retrieve collection by name'
};

module.exports = MongoClient;

/**
 * Service
 * @constructor
 */
function MongoClient( config ) {
    // new
    if (!( this instanceof MongoClient ))
        return new MongoClient( config );
    // super
    emitter.call( this );

    // locals
    this.client = null;
    this._config = {};
    this._databases = {};
    this._collections = {};

    this.configure( config );
}
util.inherits( MongoClient, emitter );

MongoClient.prototype.configure =
    function( cfg ) {
        // args
        var cfg = cfg || {},
            // todo: inline defaults values
            options = [ 'host', 'port', 'database', 'writes', 'reconnect' ];

        // apply passed configuration
        options.forEach( function( opt ) {
            // get values
            var value = cfg[ opt ]
                || dot( cfg, 'defaults.mongodb.' + opt );
            // set in config
            if ( undefined !== value )
                this._config[ opt ] = value;
        }, this );

        // force to get collection refs
        if ( cfg.collection )
            this._collections[ cfg.collection ] = true;
    };

MongoClient.prototype.init =
    function( libs, callback ) {

        // connection
        var self = this,
            server = new mongo.Server(
                self._config.host,
                self._config.port,
                { auto_reconnect: self._config.reconnect }
            );
        // select database
        self.client = new mongo.Db(
            self._config.database,
            server,
            { w: self._config.writes }
        );

        // errors
        self.client.on( 'error', function( err ) {
            console.log( 'MongoDb Driver Error:', err );
            process.exit( 1 );
        });

        // connect

        self.client.open( function( err, cli ) {
            if ( err ) {
                console.log( 'MongoDb Error Connect Database', err );
                process.exit( 2 );
            }

            // get collections
            var queue = [];
            Object.keys( Object( self._collections )) .forEach( function( name ) {
                queue.push( function( next ) {
                    self.collection( name, next );
                });
            });
            async.parallel( queue, function( err, res ) {
                if ( err ) {
                    console.log( 'MongoDb Error prepare Collections', err );
                    process.exit( 3 );
                }

                // ready
                self.emit( 'ready', self.client );
                callback && callback();

            });
        });

        return self;
    };

/**
 * Get mongodb collection by name
 * @param {String} name
 * @param {Function} callback =null
 * @return {*} Collection object | undefined
 */
MongoClient.prototype.collection =
    function( name, callback ) {
        var self = this,
            col;

        // no name
        if ( !name ) {
            // user name of the firt collection in set
            name = Object.keys( Object( this._collections )).shift();
        }
        if ( !name ) {
            callback && callback( errors.collection_name );
            return;
        }
        // get collection
        col = self._collections[ name ];

        // return cached
        if ( col && true !== col ) {
            callback && callback( null, col );
            return col;
        }
        // unsafe retrieve
        if ( !callback ) {
            col = self.client.collection( name );
            if ( col ) self._collections[ name ] = col;
        }
        // safe retrieve
        self.client.collection( name, function( err, col ) {
            if ( col ) self._collections[ name ] = col;
            callback && callback( null, col );
        });
    };
